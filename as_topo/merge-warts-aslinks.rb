#!/usr/bin/env ruby

#############################################################################
## Merges AS links files generated by warts-aslinks.
##
## Because warts-aslinks generates output in the same format as 
## skitter_as_links, you can run this on skitter_as_links output files, too.
##
## --------------------------------------------------------------------------
## Copyright (C) 2007-2008 The Regents of the University of California.
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
## 
## $Id: merge-warts-aslinks,v 1.8 2013/07/02 15:16:37 youngh Exp $
#############################################################################

require 'rubygems'
require 'ostruct'
require 'optparse'

$options = OpenStruct.new

opts = OptionParser.new
opts.banner = "Usage: merge-warts-aslinks [options] <aslinks-file-1> ..."

opts.on("-v", "--[no-]verbose", TrueClass, "show detailed progress") do |v|
  $options.verbose = v
end

begin
  ARGV.replace opts.parse(*ARGV)
rescue OptionParser::ParseError
  $stderr.puts "ERROR: " + $!.to_s
  $stderr.puts opts
  exit 1
end

#===========================================================================
#===========================================================================

class ASLinks

  def initialize
    @monitor_info = []  # index to "IP_addr\tAS_number\tindex"

    # "AS1\tAS2\tmonitor" => min_gap_length
    @links = {}

    @timestamp_min = nil
    @timestamp_max = nil
  end

  def print_all
    printf "T\t%d\t%d\n", @timestamp_min, @timestamp_max

    @monitor_info.each do |info|
      printf "M\t%s\n", info
    end

    print_aslinks
  end

  def print_aslinks
    current_aslink = nil
    current_aslink_state = {}  # gap_length => [ monitor ]

    @links.keys.sort.each do |k|
      gap_length = @links[k]

      src_as, dest_as, monitor = k.split
      aslink = "#{src_as}\t#{dest_as}"

      if aslink != current_aslink
        print_aslink_lines current_aslink, current_aslink_state 
        current_aslink = aslink
        current_aslink_state = {}
      end

      (current_aslink_state[gap_length] ||= []) << monitor.to_i
    end
        
    print_aslink_lines current_aslink, current_aslink_state 
  end

  def print_aslink_lines aslink, aslink_state
    return if aslink == nil || aslink_state.empty?

    aslink_state.keys.sort.each do |gap_length|
      if gap_length == 0
        printf "D\t%s", aslink
      else
        printf "I\t%s\t%d", aslink, gap_length
      end

      aslink_state[gap_length].sort.each do |monitor|
        printf "\t%d", monitor
      end
      puts
    end
  end

  def register_monitor(address, as, key)
    as_value = (as ? as : "UNKNOWN")
    @monitor_info << "#{address}\t#{as_value}\t#{key}"
  end

  def add_link(monitor, src_as, dest_as, gap_length)
    return if src_as == dest_as
    key = "#{src_as}\t#{dest_as}\t#{monitor}"
    print "LINK: ", key, "\t", gap_length, "\n" if $options.verbose
    min_gap_length = @links[key]
    if min_gap_length == nil || min_gap_length > gap_length
      @links[key] = gap_length
    end
  end

  def add_timestamp(timestamp)
    if @timestamp_min == nil || @timestamp_min > timestamp
      @timestamp_min = timestamp
    end

    if @timestamp_max == nil || @timestamp_max < timestamp
      @timestamp_max = timestamp
    end
  end

  def links
    retval = []
    @links.each do |k, v|
      src_as, dest_as, monitor = k.split
      retval << [ src_as, dest_as, monitor, v ]
    end
    retval.sort
  end

end


#############################################################################

def read_lines(path, &block)
  command = nil
  case path
  when /\.gz$/ then command = "gzip -dc"
  when /\.bz2$/ then command = "bzip2 -dc"
  when /\.lzo$/ then command = "lzop -dc"
  end

  if command
    ENV['MERGEWARTS_PATH'] = path
    IO.popen(command + " \"$MERGEWARTS_PATH\"") do |io|
      io.each &block
    end
  else
    IO.foreach path, &block
  end
end

#############################################################################
# Main
#############################################################################

trace_count = 0
metadata = []

monitor_as = {}  # IP address => AS
monitor_key = {}  # IP address => key
aslinks = ASLinks.new

last_generation_tool = nil
last_bgp_table = nil
ARGV.each do |path|
  key_map = []  # file-specific key => merged key

  read_lines(path) do |line|
    line.chomp!
    next if line =~ /^\s*$/

    if line =~ /^\#INFO: ([^=]+)=(.+)$/
      key, value = $1, $2
      case key
      when "generation_timestamp"
        next  # ignore
      when "generation_tool"
        if value != last_generation_tool
          metadata << "#INFO: previous_generation_tool=" + value
        end
        last_generation_tool = value
      when "trace_count"
        trace_count += value.to_i
      when "bgp_table"
        metadata << line if value != last_bgp_table
        last_bgp_table = value
      else
        metadata << line
      end
    elsif line =~ /^\#/
      next  # ignore format description
    else
      fields = line.split
      case fields[0]
      when "T"
        aslinks.add_timestamp fields[1].to_i
        aslinks.add_timestamp fields[2].to_i

      when "M"
        address, as = fields[1..2]
        key = fields[3].to_i

        if monitor_as.has_key? address
          # overwrite the monitor AS if the previous AS value was nil
          # and the new AS is not nil
          monitor_as[address] ||= as unless as == "UNKNOWN"
          key_map[key] = monitor_key[address]
        else
          monitor_as[address] = (as == "UNKNOWN" ? nil : as)
          key_map[key] = monitor_key.length 
          monitor_key[address] = monitor_key.length
        end

      when "I"
        src_as, dest_as = fields[1..2]
        gap_length = fields[3].to_i
        fields[4 .. -1].each do |key|
          aslinks.add_link key_map[key.to_i], src_as, dest_as, gap_length
        end

      when "D"
        src_as, dest_as = fields[1..2]
        fields[3 .. -1].each do |key|
          aslinks.add_link key_map[key.to_i], src_as, dest_as, 0
        end

      else
        $stderr.puts "ERROR: malformed line '#{line}' in '#{path}'"
        exit 1
      end
    end
  end
end

# Ensure monitor lines appear in sorted order by key.
monitor_key.to_a.sort_by { |address, key| key }.each do |address, key|
  aslinks.register_monitor address, monitor_as[address], key
end

#=========================================================================

now = Time.now
printf "#INFO: generation_tool=%s\n", "$Id: merge-warts-aslinks,v 1.8 2013/07/02 15:16:37 youngh Exp $"
printf "#INFO: generation_timestamp=%d (%s)\n", now.to_i, now.to_s
printf "#INFO: trace_count=%d\n", trace_count
metadata.each do |line| puts line end

puts <<'EOF'
#===========================================================================
# Format Description
#---------------------------------------------------------------------------
#
# This file contains AS links derived from scamper traceroute traces.
# This is a line-oriented file format, with each line consisting of
# tab-separated fields.  The first field specifies the type of data
# provided in the remaining fields.
#
# The following is a description of each type of line:
#
# ..........................................................................
#   T   earliest_timestamp   latest_timestamp
#   T       1193875543          1194039574
#
#      This line provides the earliest and latest timestamps of the traces
#      used to obtain these AS links.  The timestamp of a trace is taken at
#      the start of a trace.
#
# ..........................................................................
#   M   IP_address   AS_number   key
#   M   10.25.12.1     1909       0
#
#      This line describes a single "monitor" (that is, a host computer)
#      from which scamper measurements were made.  The AS number is
#      determined by mapping the monitor IP address to AS number using the
#      same BGP table used to convert the traces to AS links.  Hence, there
#      is a slight possibility of not finding an AS number.  When that
#      happens, the AS number field will contain the value "UNKNOWN".
#      (It is also possible for the AS number to be a multi-origin AS or
#      an AS set.)
#
#      The monitor key is a unique number used to indicate which monitors
#      observed a given AS link in the AS link lines described below.
#
#        NOTE: The monitor key is only unique to a given AS links file.
#              The same monitor can have different keys in different
#              files, so you must be careful when merging AS links files.
#              Use the IP address if you need to uniquely identify monitors
#              across files.
#
# ..........................................................................
#   D    from_AS    to_AS   monitor_key1   monitor_key2   ...
#   D     1909       1227        0              3
#
#      This line describes a direct AS link between from_AS and to_AS.
#      A direct AS link exists if two adjacent IP hops in a traceroute
#      path map to two distinct ASes.
#
#      For example:
#
#        IP path: ...  10.0.0.1  10.0.0.2  192.168.0.1  192.168.0.2  ...
#        AS path: ...      A         A          B            B       ...
#                                     \        /
#                          There is a direct AS link from A to B.
#
#      Note that the AS link is in the same direction as the IP path;
#      for example, the link is A to B and not B to A.  More generally,
#      the from_AS is the AS that passed the traffic out, and the to_AS
#      is the AS that received the traffic.
#
#      The monitor_key columns specify the monitors that saw the given
#      AS link in their traces.
#
# ..........................................................................
#   I   from_AS   to_AS   gap_length   monitor_key1   monitor_key2   ...
#   I     1909     1227        2            0              3
#
#      This line describes an indirect AS link between from_AS and to_AS.
#      An indirect AS link exists if two ASes in an AS path are separated
#      by a gap caused by either an unresponsive hop or an inability to
#      map an IP address to an AS number.
#
#      For example, suppose the IP path has two consecutive unresponsive
#      hops (*) between 10.0.0.1 and 192.168.0.1:
#
#        IP path: ...  10.0.0.1  *  *  192.168.0.1  ...
#        AS path: ...      A     *  *      B        ...
#                           \             /
#         There is an indirect AS link from A to B of gap length 2.
#
#      As another example, suppose no AS number can be found for the
#      address 172.16.0.1:
#
#        IP path: ...  10.0.0.1  172.16.0.1  192.168.0.1 ...
#        AS path: ...      A         *           B
#                           \                   /
#         There is an indirect AS link from A to B of gap length 1.
#
#      If two different monitors see gaps of differing lengths between the
#      same pair of ASes, then there will be two separate indirect link
#      lines.  For example, suppose we have
#
#        monitor 0's AS path: ...  A  *  *  *  B  ...
#        monitor 1's AS path: ...  A  *  B  ...
#
#      Then there will be two indirect link lines:
#
#        I   from_AS   to_AS   gap_length   monitor_key   ...
#        I      A        B          3            0
#        I      A        B          1            1
#
#      If the same monitor sees gaps of differing lengths between the
#      same pair of ASes in different traces, then the minimum observed
#      gap length will be recorded in the indirect link line:
#
#        monitor 0's AS path (trace 1): ...  A  *  *  *  B  ...
#        monitor 0's AS path (trace 2): ...  A  *  B  ...
#
#      Then there will be a single indirect link line with the minimum
#      gap length:
#
#        I   from_AS   to_AS   gap_length   monitor_key   ...
#        I      A        B          1            0
#
#===========================================================================
#
# NOTE: In all places where an AS number can appear in this file format,
#       there can also be an AS set or a multi-origin AS (MOAS).  An AS set
#       is a valid component of BGP AS paths.  They are usually printed as
#       a list of comma-separated AS numbers enclosed in curly braces; for
#       example, {32,54}.  In this file format, AS sets are printed without
#       the curly braces: 32,54.  AS sets will never have spaces around the
#       comma separator.
#
#       A multi-origin AS occurs when a given BGP prefix is announced by
#       more than one AS.  Suppose some prefix 10.0.0.0/8 is announced in
#       the BGP table by both AS 10 and AS 20.  Then an address in that
#       prefix, like 10.0.0.1, will map to both AS 10 and AS 20.  This is
#       indicated by using the pseudo AS number 10_20.  If AS 30 also
#       announces that prefix, then you would see 10_20_30.  If the AS set
#       {32,54} also announces the prefix, then you would see
#       10_20_30_32,54 where the grouping is AS 10, AS 20, AS 30, and the
#       AS set {32,54}.  NOTE: A value like 10_32,54_20_30 means the same
#       thing as 10_20_30_32,54.
#
#===========================================================================
EOF

aslinks.print_all
exit 0
